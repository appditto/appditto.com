{"id":"5ddece2f2cf19825f43f84f9","uuid":"04d4d9f2-9028-461b-a4ef-36b602186d71","title":"Automate Your Flutter Workflow Using GitLab CI/CD and Fastlane","slug":"automate-your-flutter-workflow","html":"<figure class=\"kg-card kg-image-card\"><img src=\"https://ghost.appditto.com/content/images/2019/12/flutter-automation-2-1.png\" class=\"kg-image\" alt=\"Flutter Automation with GitLab &amp; Fastlane\"></figure><p><a href=\"https://flutter.io/\" rel=\"noopener nofollow\"><strong><strong>Flutter</strong></strong></a> is a modern mobile app development framework that lets you develop beautiful, highly performant apps in very little time. At Appditto we already have multiple Flutter applications in production — including open source projects like <a href=\"http://natrium.io/\" rel=\"noopener nofollow\"><strong><strong>Natrium</strong></strong></a>, <a href=\"http://kalium.banano.cc/\" rel=\"noopener nofollow\"><strong><strong>Kalium</strong></strong></a>, and <a href=\"http://blaisewallet.com/\" rel=\"noopener nofollow\"><strong><strong>Blaise</strong></strong></a>. The biggest pain point of our development process has been the testing, building, and deploying process for all of our apps.</p><h2 id=\"the-old-way-without-ci-cd-or-fastlane\">The old way…without CI/CD or Fastlane</h2><p>If you’ve ever gotten any mobile application into production you can understand the general process, usually it looks like this:</p><ol><li>Run tests…<em><em>and wait</em></em></li><li>Tag the release</li><li>Build the signed android binary (<code>.aab</code> or <code>.apk</code>) …<em><em>and wait</em></em></li><li>Login to the Google Play Developer Console and create a new release</li><li>Upload it to Google Play…<em><em>and wait</em></em></li><li>Fill in your changelog(s) and other general information and publish your app</li></ol><p>In the case of a cross-platform app, we can’t forget about iOS</p><ol><li>Start any iOS-specific tests…<em><em>and wait</em></em></li><li>Build the ios app (<code>flutter build iOS</code>)…<em><em>and wait</em></em></li><li>Archive the app in xcode…<em><em>and wait</em></em></li><li>Upload the app to the App Store via xcode…<em><em>and wait</em></em></li><li><em><em>And wait</em></em> for the App Store to process your upload</li><li>Log in to App Store Connect and create a new release</li><li>Fill in any changelog(s) and other information and submit it for review</li></ol><h2 id=\"what-s-wrong-with-all-of-that-you-might-ask\">What’s wrong with all of that, you might ask?</h2><p>Just to name a few…</p><ul><li>The entire process for just <strong><strong>1 app</strong></strong> can take more than an hour, just to get it submitted for review.</li><li>If you introduced a change that caused tests to fail, you don’t know about it until you are ready to release an update.</li><li>If you introduced a change that caused the build to fail, you don’t know about it until you try to build it.</li><li>It’s prone to user error. There’s a lot of steps in the process, it can be easy to miss something.</li></ul><h2 id=\"the-solution-continuous-integration-continuous-delivery\">The Solution: Continuous Integration &amp; Continuous Delivery</h2><p>We identified the need for <a href=\"https://en.m.wikipedia.org/wiki/Continuous_integration\" rel=\"noopener nofollow\"><strong><strong>continuous integration</strong></strong></a> and <a href=\"https://en.wikipedia.org/wiki/Continuous_delivery\" rel=\"noopener nofollow\"><strong><strong>continuous delivery</strong></strong></a> (referred to as CI/CD) almost immediately, but there’s a lot of competing solutions out there that we wanted to research and try before choosing the one that best fit our needs.</p><p>For our Flutter applications we needed to:</p><ul><li>Automate tests for dart code, Android code, and iOS code</li><li>Automate building the iOS and Android applications</li><li>Automate deployments to the iOS App Store and the Google Play Store</li></ul><p><a href=\"https://fastlane.tools/\" rel=\"noopener nofollow\"><strong><strong>Fastlane</strong></strong></a> is the first part of our continuous integration solution, it is a powerful tool that allows you to automate iOS and Android builds, as well as automate deployments to both of the app stores. It also has several other benefits such as allowing us to manage store information, changelogs, and more in our repository.</p><p>In this guide, we’ll walk through the steps required to integrate GitLab CI/CD and Fastlane into your project.</p><h2 id=\"before-we-get-started-\">Before we get started…</h2><p>This article makes a few assumptions you should be aware of.</p><ul><li>Everything described is applicable to <strong><strong>Unix environments only</strong></strong> — such as MacOS or Linux. <strong><strong>If you are using Windows</strong></strong>, using the <a href=\"https://docs.microsoft.com/en-us/windows/wsl/install-win10\" rel=\"noopener nofollow\"><strong><strong>WSL</strong></strong></a> is required.</li><li>MacOS is required to build and sign iOS apps. You can skip the iOS sections if you are only planning to build for Android or don’t have access to a Mac.</li><li>You need to have an <a href=\"https://developer.apple.com/\" rel=\"noopener nofollow\"><strong><strong>Apple Developer Account</strong></strong></a> to publish iOS apps to the App Store</li><li>You need to have a <a href=\"https://developer.android.com/distribute\" rel=\"noopener nofollow\"><strong><strong>Google Play Developer Account</strong></strong></a> to publish Android apps to the Play Store.</li><li><strong><strong>App Store Privileges — </strong></strong>It’s very important for CI that we add a second account to App Store Connect without 2FA-enabled. You can give it the “App Manager” permission and a secure password. If you aren’t sure how to add an additional user, <a href=\"https://support.appmachine.com/hc/en-us/articles/203647716-Authorize-an-Additional-User-to-your-iOS-Developer-Account\" rel=\"noopener nofollow\"><strong><strong>here’s a guide</strong></strong></a>. Anywhere you are asked for credentials for the app store, you will need to use this account.</li><li>Git Usage— It’s assumed that you are using Git for source control. It doesn’t matter if your repository is self-hosted, on GitHub, on Bitbucket, on GitLab, etc.</li></ul><p>This guide will assume that you want to automate tests, builds, and deployments to both of the app stores — which means that all of the above is required to completely follow this guide.</p><h2 id=\"getting-started-with-fastlane-and-flutter\">Getting started with Fastlane and Flutter</h2><p>We need to get Fastlane installed and configured for our project. The first step is to install fastlane, it can be installed with <code><a href=\"https://guides.rubygems.org/command-reference/\" rel=\"noopener nofollow\"><strong><strong>gem</strong></strong></a></code>.</p><pre><code class=\"language-shell\"># gem install fastlane</code></pre><p>Next navigate to the root of your Flutter project, where you need to initialize fastlane for both android and iOS.</p><pre><code># cd path_to_my_awesome_flutter_app</code></pre><p>First, you might want to add the following lines to <code>.gitignore</code>.</p><pre><code># You definitely want these\n**/ios/*.ipa\n**/ios/*.app.dSYM.zip\n\n# These are optional\n# For our open source projects we choose to exclude some metadata that contains private information\nandroid/fastlane/report.xml\nios/fastlane/report.xml\nios/fastlane/Preview.html\nios/fastlane/metadata/review_information\nios/fastlane/metadata/trade_representative_contact_information\n</code></pre><p><strong><strong>Fastlane install for Android builds and deployments:</strong></strong></p><p>You need to obtain a json file that contains an access key from the Google Play Console. More details available in the <a href=\"https://docs.fastlane.tools/getting-started/android/setup/\" rel=\"noopener nofollow\"><strong><strong>fastlane docs</strong></strong></a>.</p><p>We recommend that you keep this file outside of your repository and in your home directory <code><strong><strong>/home/&lt;YOUR USER&gt;/keys/android/myaccesskey.json</strong></strong></code> or <code><strong><strong>/Users/&lt;YOUR USER&gt;/keys/android/myaccesskey.json</strong></strong></code> (for MacOS). When prompted by fastlane use the path <code><strong><strong>~/keys/android/myaccesskey.json</strong></strong></code> as the location where you stored your key.</p><pre><code># cd android\n# fastlane init\n# cd ..</code></pre><p>Follow the prompts and make sure all of the information is correct, fastlane will create several files in your project once you are finished.</p><p><strong><strong>Fastlane install for iOS builds and deployments:</strong></strong></p><p>As mentioned in the pre-requisites, you want a dedicated account without 2FA to use for continuous integration. For iOS, the fastlane installation is similar but you’ll need to use the apple ID and password of your developer account without 2FA.</p><pre><code># cd ios\n# fastlane init\n# echo 'gem \"cocoapods\"' &gt;&gt; Gemfile\n# cd ..</code></pre><p>Follow through the prompts and make sure the detected information is correct. Managing metadata is up to you, it means you can manage changelogs, descriptions, icons, and other data from within your project. In our case, we chose yes for those (with the exception of ios review_information and iOS trade representative contact information — simply delete the metadata you don’t want to manage via fastlane, and add it to <code><strong><strong>.gitignore</strong></strong></code>).</p><p>You can check in and push all of the files fastlane has created in your project.</p><h2 id=\"a-word-on-code-signing-android\">A word on code signing…Android</h2><p>This article assumes you have setup code signing for your android app as described in the <a href=\"https://flutter.dev/docs/deployment/android\" rel=\"noopener nofollow\"><strong><strong>flutter documentation</strong></strong></a>. That means a <code>.<strong><strong>jks</strong></strong></code> key store, with a <code><strong><strong>key.properties</strong></strong></code> file excluded from source control that has the password, keyAlias, etc.</p><p>If you haven’t configured code signing yet, then follow the steps <a href=\"https://flutter.dev/docs/deployment/android#signing-the-app\" rel=\"noopener nofollow\"><strong><strong>outlined here</strong></strong></a><strong><strong> </strong></strong>before continuing with this guide.</p><h2 id=\"a-word-on-code-signing-ios\">A word on code signing…iOS</h2><p>For <strong>iOS</strong>, the story is a bit more complicated.</p><p>We’re going to use <a href=\"https://docs.fastlane.tools/actions/match/\" rel=\"noopener\"><strong>Fastlane Match</strong></a>, to manage the certificates required for code signing on iOS. Here’s how to do it.</p><ol><li>Create a <strong>private </strong>git repository named <code><strong>ios-certificates.git</strong></code> or similar</li><li>Run the following</li></ol><pre><code># cd ios\n# fastlane match init\n# fastlane match\n# cd ..</code></pre><p>Follow the prompts to setup match, once completed it will create <code><strong>ios/fastlane/Matchfile</strong></code>, which contains information about the ios-certificates repository.</p><h2 id=\"configuring-fastlane-for-flutter-and-gitlab-android-\">Configuring Fastlane for Flutter and GitLab (Android)</h2><p>We installed fastlane with <code><strong>fastlane init</strong></code>, and it configured itself for an Android project. The problem is, fastlane configured itself for an Android project — not for a Flutter project.</p><p>The main fastlane configuration can be found in <code><strong>android/fastlane/Fastfile</strong></code>, it has some default <a href=\"https://docs.fastlane.tools/advanced/lanes/\" rel=\"noopener\">lanes</a>. You can think of a <strong>lane</strong> as a group of tasks. The Fastfile is written in Ruby, so you can write any ruby code within it.</p><p>We want two new lanes for android, <code><strong>build_android</strong></code> and <code><strong>deploy_android</strong></code>. The first builds and signs our Android app, the second uploads it to the play store.</p><p>We’re going to make some simple shell scripts to build the app and run tests, to keep our Fastfile clean.</p><pre><code># touch android/fastlane/flutter_build.sh\n# touch android/fastlane/flutter_test.sh\n# chmod a+x android/fastlane/flutter_build.sh\n# chmod a+x android/fastlane/flutter_test.sh</code></pre><p>These create two empty scripts and make them executable (You can skip flutter_test.sh all together if you are planning to add GitLab as it will become redundant in our pipeline)</p><p>Contents of <code><strong>flutter_build.sh</strong></code>:</p><!--kg-card-begin: html--><script src=\"https://gist.github.com/bbedward/f7e32bfd159f55e74f0844b39c7d74ae.js\"></script><!--kg-card-end: html--><p>Contents of <code><strong><strong>flutter_test.sh</strong></strong></code>:</p><!--kg-card-begin: html--><script src=\"https://gist.github.com/bbedward/2abcb8973405647d6c16471bc2e60e66.js\"></script><!--kg-card-end: html--><p>Now we can create our lanes in <code><strong><strong>android/fastlane/Fastfile</strong></strong></code></p><!--kg-card-begin: html--><script src=\"https://gist.github.com/bbedward/e59644e5d840a2d104c119d2c850475a.js\"></script><!--kg-card-end: html--><p>Breaking down the first lane, <code><strong><strong>build_android</strong></strong></code>:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://ghost.appditto.com/content/images/2019/11/build_android.png\" class=\"kg-image\" alt=\"build_android lane\"><figcaption>build_android lane</figcaption></figure><ul><li><code><strong><strong>sh \"./flutter_test.sh\"</strong></strong></code> : Executes our tests, you may choose to remove this especially when using GitLab CI as we’ll do tests earlier in our pipeline.</li><li><code><strong><strong>sh \"./flutter_build.sh\" --clean</strong></strong></code> : This builds our <code><strong><strong>.aab</strong></strong></code> (<a href=\"https://developer.android.com/platform/technology/app-bundle\" rel=\"noopener nofollow\">Android App Bundle</a>), this is the binary we want to use when uploading to the play store.</li><li><code><strong><strong>sh \"./flutter_build.sh\" --apk</strong></strong></code> : This builds our standard fat <code><strong><strong>.apk</strong></strong></code>, it’s also completely optional but we like to have it in our archive as it’s easier to install if you want to downgrade to a specific version, offer a download in alternative places, etc.</li></ul><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://ghost.appditto.com/content/images/2019/11/deploy-to-play-store.png\" class=\"kg-image\" alt=\"deploy_android lane\"><figcaption>deploy_android lane</figcaption></figure><p>Our second lane, <code><strong><strong>deploy_android</strong></strong></code>, is where things get interesting.</p><p>In this lane we are uploading our build to the play store using the fastlane function <a href=\"https://docs.fastlane.tools/actions/upload_to_play_store/\" rel=\"noopener nofollow\">upload_to_play_store</a>. This single lane allows us to upload to production, beta, alpha, or internal tracks — pretty neat!</p><p>You can use these lanes as demonstrated below:</p><pre><code>Build the release binaries:\n# bundle exec fastlane build_android\nProduction deploy:\n# bundle exec fastlane deploy_android production:true\nBeta deploy:\n# bundle exec fastlane deploy_android beta:true\nAlpha deploy:\n# bundle exec fastlane deploy_android alpha:true\nInternal track deploy:\n# bundle exec fastlane deploy_android internal:true</code></pre><p>And we’re done! Fastlane can now build and deploy our Flutter application. We’ll automate this process later, but first we need to configure our iOS build.</p><h2 id=\"configuring-fastlane-for-flutter-and-gitlab-ios-\">Configuring Fastlane for Flutter and GitLab (iOS):</h2><p><strong><strong>Note: A MacOS machine with the latest XCode installed is needed for this section</strong></strong></p><p>Building for iOS and deploying to the App Store is a bit more problematic, mainly because there’s more steps involved. Luckily we can still simplify the process with Fastlane.</p><p>We want to start with creating the same two scripts we made for Android</p><pre><code># touch ios/fastlane/flutter_build.sh\n# touch ios/fastlane/flutter_test.sh\n# chmod a+x ios/fastlane/flutter_build.sh\n# chmod a+x ios/fastlane/flutter_test.sh</code></pre><p>The contents of <code><strong><strong>flutter_build.sh</strong></strong></code>:</p><!--kg-card-begin: html--><script src=\"https://gist.github.com/bbedward/ce9ca0571f24d03f1416cb5756ffdc09.js\"></script><!--kg-card-end: html--><p><code><strong><strong>--no-codesign</strong></strong></code> is used in our flutter build step because unlike android, flutter build doesn’t give us a binary that can be uploaded straight to the AppStore. There’ll be an additional build step later which will be where we sign our app.</p><p>And <code><strong><strong>flutter_test.sh</strong></strong></code>:</p><!--kg-card-begin: html--><script src=\"https://gist.github.com/bbedward/4f68dc196e9cf927a417912fac93b08b.js\"></script><!--kg-card-end: html--><p>Now we need to create our lanes, like how we did on Android.</p><p>Like android, we also want a <code><strong><strong>build_ios</strong></strong></code> that builds and signs our app, as well as a <code><strong><strong>deploy_ios</strong></strong></code> that uploads our app to the app store.</p><p>Here’s the whole file, we’ll walk through what it means later:</p><!--kg-card-begin: html--><script src=\"https://gist.github.com/bbedward/9f70e98b08938e708f7c3307a4bc706b.js\"></script><!--kg-card-end: html--><p>The Fastfile is <strong><strong>Ruby </strong></strong>syntax, so when we define variables and functions it’s written in Ruby.</p><p>The first group of functions and variables are for creating a temporary keychain which will be used to store our signing and deploy keys.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://ghost.appditto.com/content/images/2019/11/temp-keychain.png\" class=\"kg-image\" alt=\"Temporary keychain variables\"><figcaption>Temporary keychain variables</figcaption></figure><p>First we set a couple of variables with the temporary keychain name and password. These are “default” values because we also have the option to include a more secure password from the environment, which we’ll see later.</p><p>Then we have a few ruby functions which create and delete our temporary keychain.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://ghost.appditto.com/content/images/2019/11/temp-key-chain-function.png\" class=\"kg-image\" alt=\"Functions for creating &amp; deleting temporary keychains\"><figcaption>Functions for creating &amp; deleting temporary keychains</figcaption></figure><ul><li><code><strong><strong>delete_temp_keychain</strong></strong></code> will delete the temporary keychain if it exists</li><li><code><strong><strong>create_temp_keychain</strong></strong></code> will create the temporary keychain with a name and password</li><li><code><strong><strong>ensure_temp_keychain</strong></strong></code> simply deletes any existing keychain of the same name, and creates a new one with the given name and password.</li></ul><h3 id=\"why-use-a-temporary-keychain\">Why use a temporary keychain?</h3><p>It’s not required to create a new keychain every time you build the app with Fastlane — the default Login keychain, or any other keychain on your system is perfectly fine. There’s a couple reasons we prefer this method over using the login keychain.</p><ol><li>You don’t need to expose your login password. If you use your login keychain with Fastlane, it will prompt you for a password to unlock it when you run <code><strong><strong>match</strong></strong></code> — not really a problem on a development machine, but for CI/CD we don’t want to be prompted for a password. So we can either provide our login password in the environment or use a different keychain — which is what we’re doing here.</li><li>You can provide a strong, random password every time when the process is automated via GitLab — which we’ll see later. This ties into increased security.</li></ol><p>Then we have our two lanes, similar to android. One is the build step and one is the upload step.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://ghost.appditto.com/content/images/2019/11/two-lane.png\" class=\"kg-image\" alt=\"build_ios lane\"><figcaption>build_ios lane</figcaption></figure><p>Breaking down the <code><strong><strong>build_ios</strong></strong></code> lane</p><ul><li>It disables “Automatic code signing” which is what we want for our CI/CD server. The <code><strong><strong>disable_code_signing</strong></strong></code><strong><strong> </strong></strong>method actually changes your <code>.xcodeproj</code>file, if you run this locally you probably don’t want to check the modified file into git. You could backup the original at the beginning of the lane if desired, and restore it later by doing something like <code>cp Runner.xcodeproj Runner.xcodeproj.bak</code>.</li><li>It creates our temporary keychain with a name and password from the environment, otherwise uses the default one.</li><li>It runs fastlane match, to install the certificates and profiles into the temporary keychain</li><li>It runs the flutter tests and build</li><li>It builds the <code><strong><strong>.ipa</strong></strong></code> file and signs it, which is what we need to upload to the App Store</li><li>It deletes our temporary keychain at the end</li></ul><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://ghost.appditto.com/content/images/2019/11/upload-to-app-store.png\" class=\"kg-image\" alt=\"deploy_ios lane\"><figcaption>deploy_ios lane</figcaption></figure><p>And the <code><strong><strong>deploy_ios</strong></strong></code> lane is where things get really cool</p><ul><li>It can upload to test flight</li><li>It can upload to the App Store and <em><em>submit it for review </em></em>automatically! It will upload, make sure everything is valid, wait for processing, then submit it for review all in one step.</li></ul><p>Like android you can do either or with parameters</p><pre><code># cd ios\nTo upload to testflight:\n# bundle exec fastlane deploy_ios testflight:true\nTo submit for review:\n# bundle exec fastlane deploy_ios</code></pre><h3 id=\"one-more-thing\">One more thing</h3><p>For iOS apps, if we want to automatically submit them for review we need to set the answers for our compliance questions. You can add the following to <code><strong><strong>ios/fastlane/Deliverfile</strong></strong></code>, but change the answers as they apply to your app.</p><!--kg-card-begin: html--><script src=\"https://gist.github.com/bbedward/50f92ecad5d2f82f4ff9fadffda11cac.js\"></script><!--kg-card-end: html--><p>And we’re done with Fastlane!</p><p>You can now build and deploy your iOS and Android apps in a couple simple steps.</p><h2 id=\"automating-all-of-it-with-gitlab-ci-cd\">Automating all of it with GitLab CI/CD</h2><p>Now that we can build and deploy our apps with a few simple commands, it’s time to automate it. This is where continuous integration comes in.</p><h3 id=\"why-gitlab\">Why GitLab?</h3><p>There’s plenty of continuous integration/continuous delivery (CI/CD) solutions out there including <a href=\"https://travis-ci.org/\" rel=\"noopener nofollow\">Travis CI</a>, <a href=\"https://github.com/features/actions\" rel=\"noopener nofollow\">GitHub Actions</a>, <a href=\"https://codemagic.io/\" rel=\"noopener nofollow\">Codemagic</a>, <a href=\"https://bitbucket.org/product/features/pipelines\" rel=\"noopener nofollow\">Bitbucket pipelines</a>, <a href=\"https://circleci.com/\" rel=\"noopener nofollow\">Circle CI</a>, <a href=\"https://jenkins.io/\" rel=\"noopener nofollow\">Jenkins</a>, etc. I encourage you to research all of them and determine which one fits your needs the best. For us, we determined that GitLab’s CI/CD would work best for us. That definitely won’t be the case for every team or every project, but here’s the reasons we chose it over the others:</p><ul><li><strong><strong>Ability to use your own </strong></strong><a href=\"https://docs.gitlab.com/runner/\" rel=\"noopener nofollow\"><strong><strong>runner</strong></strong></a>. Think of a runner like a “worker” — it executes your pipelines and in our case will be responsible for running tests, building the apps, and uploading the apps. Many of the services mentioned only allow you to use their shared servers with limited usage caps. Many offer enterprise solutions, paid plans, and various other things to fit your needs — so again, definitely research them and find what works best for you.</li><li><strong><strong>MacOS Requirement.</strong></strong> Flutter applications <strong><strong><em><em>need</em></em></strong></strong> MacOS to build the iOS binary and upload to the App Store. If you don’t intend to server iOS users, then this doesn’t apply to you. Most of the services above provide MacOS servers that you can use (GitLab happens to not provide these), but they’re generally more expensive and more restrictive. Also, we’re dealing with very sensitive data — signing and deploy keys, app store manager passwords, google play upload keys, etc. Unless you’re using an enterprise solution offered by one of the above mentioned CIs, this may not be something your internal audit requirements allow for.</li><li><strong><strong>Intuitive Configuration.</strong></strong> The <a href=\"https://yaml.org/\" rel=\"noopener nofollow\">yaml</a> configuration that GitLab uses is very straightforward, easy to understand, and easy to work with. You can build very complex pipelines in very little time.</li><li><strong><strong>Intuitive Interface.</strong></strong> The experience using GitLab is generally good. It has an interface where you can easily visualize and manage your pipelines, alerts, auto-cancel features, archiving, and a lot more that really fits our needs.</li></ul><p>If your project isn’t already in GitLab, you can create a new one, import one, or mirror it from another repository. We chose to mirror it because our projects are hosted on <a href=\"http://github.com/\" rel=\"noopener nofollow\">GitHub</a>, but your needs may vary. <a href=\"https://docs.gitlab.com/ee/gitlab-basics/create-project.html\" rel=\"noopener nofollow\"><strong><strong>More information can be found on the GitLab website</strong></strong></a> about creating, importing, or mirroring a project.</p><h3 id=\"what-about-the-server\">What about the server?</h3><p>As I said above, GitLab does not provide any shared MacOS runners — which we need to build and deploy our iOS apps. Luckily the gitlab-runner software is incredibly easy to setup, you can run it on any MacOS machine including a MacBook.</p><p>We chose to setup a <a href=\"https://en.wikipedia.org/wiki/Bare-metal_server\" rel=\"noopener nofollow\">bare-metal</a> dedicated MacOS server, this has some downsides — primarily that we need to manage the infrastructure ourselves, keep flutter up to date ourselves, keep XCode and the Android SDK up to date ourselves, etc. However we need MacOS, which is why we chose the bare-metal option instead of using docker containers or a similar lower-maintenance solution. If you want to follow the same approach — a <a href=\"https://en.wikipedia.org/wiki/Mac_Mini\" rel=\"noopener nofollow\"><strong><strong>Mac Mini</strong></strong></a> makes a great option and used, older ones are relatively inexpensive. You can also use a hosting provider such as <a href=\"https://www.macstadium.com/\" rel=\"noopener nofollow\"><strong><strong>MacStadium</strong></strong></a> or <a href=\"http://macincloud.com/\" rel=\"noopener nofollow\"><strong><strong>MacInCloud</strong></strong></a><em><em>. </em></em>Or like I said, if you already have a MacOS development box you can simply setup the gitlab-runner on that.</p><h3 id=\"server-configuration\">Server Configuration</h3><p><strong><strong>Note: If you are intending to use the gitlab-runner on a MacOS development machine that has already been configured for flutter development and FastLane, you can skip these steps. If you are intending to build for android-only, you can skip installing XCode.</strong></strong></p><p>If you’re using a bare-metal MacOS server you need to install the required software to build iOS and Android apps.</p><ol><li><a href=\"http://www.androiddocs.com/sdk/installing/index.html\" rel=\"noopener nofollow\"><strong><strong>Install the Android SDK</strong></strong></a> — Android Studio is the easiest way to install it.</li><li><strong><strong>Install XCode</strong></strong> — via the MacOS App Store</li><li><a href=\"https://flutter.dev/docs/get-started/install/macos\" rel=\"noopener nofollow\"><strong><strong>Install Flutter</strong></strong></a> — Make sure you also add it to your PATH, as described in the document.</li></ol><p>Once these are complete, run <code><strong><strong>flutter doctor -v</strong></strong></code> to ensure everything is configured correctly.</p><p>One other thing we’ll want to do, is install XCode command line tools. This can be done by running the following command:</p><pre><code># xcode-select --install</code></pre><p>We need to add some environment variables, we can add them to <code><strong><strong>~/.zprofile</strong></strong></code> (on MacOS Catalina) or <code><strong><strong>~/.profile</strong></strong></code> (other MacOS versions)</p><pre><code>export LC_ALL=en_US.UTF-8\nexport LANG=en_US.UTF-8\n# Ruby\nexport GEM_HOME=~/.gems\nexport PATH=$PATH:~/.gems/bin</code></pre><p>You can also choose to store sensitive variables here, such as <code><strong><strong>FASTLANE_PASSWORD</strong></strong></code> (the password of the AppStore/Developer account you used to setup fastlane with) and <code><strong><strong>MATCH_PASSWORD</strong></strong></code> (the password required to decrypt your iOS certificates.</p><pre><code>export MATCH_PASSWORD=abc123\nexport FASTLANE_PASSWORD=123abc</code></pre><p>You can also choose to store variables in the GitLab interface per-project, which is what we’ll do for the rest of the guide. Just know that you have the option to do it this way.</p><h3 id=\"getting-access-to-ios-certificates\">Getting access to ios-certificates</h3><p>For fastlane match, you should have created a private git repository with all of your encrypted signing/deploy certificates. We need to give this machine access to these.</p><pre><code># ssh-keygen -t rsa</code></pre><p>Once complete, you can add <code>read-only</code> access to your repository using your public key (by default located in <code>~/.ssh/id_rsa.pub</code>). GitHub calls them <a href=\"https://developer.github.com/v3/guides/managing-deploy-keys/\" rel=\"noopener nofollow\"><strong><strong>Deploy Keys</strong></strong></a>.</p><h3 id=\"installing-keys-for-android-google-play\">Installing keys for Android/Google Play</h3><p>We need to install our <code><strong><strong>jks</strong></strong></code> key store and <code>.<strong><strong>json</strong></strong></code> file that we generated earlier. Upload it to your server and copy it to your home directory. For our example we’ll have them at <code><strong><strong>/Users/&lt;YOUR USER&gt;/keys/android/appditto.jks</strong></strong></code> and <code><strong><strong>/Users/&lt;YOUR USER&gt;/keys/android/myaccesskey.json</strong></strong></code></p><pre><code># mkdir -p /Users/&lt;YOUR USER&gt;/keys/android\n# mv myaccesskey.json ~/keys/android\n# mv appditto.jks ~/keys/android</code></pre><h2 id=\"installing-the-gitlab-runner\">Installing the GitLab Runner</h2><p>We need to install the gitlab-runner software, it’s very easy to do.</p><p>In GitLab, navigate to your project settings -&gt; CI/CD -&gt; Runners and find your registration token. It should look like this</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://ghost.appditto.com/content/images/2019/11/registeration-token-gitlab.png\" class=\"kg-image\" alt=\"GitLab runner setup\"><figcaption>GitLab runner setup</figcaption></figure><p>It just so happens that ours is <code><strong><strong>YourRegistrationToken</strong></strong></code>, we’ll need it when we setup the gitlab-runner.</p><p>To install the runner:</p><pre><code># sudo curl --output /usr/local/bin/gitlab-runner https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-darwin-amd64\n# sudo chmod +x /usr/local/bin/gitlab-runner</code></pre><p>Now that it’s installed, we can register it for our project using <code><strong><strong>gitlab-runner register</strong></strong></code>.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://ghost.appditto.com/content/images/2019/11/registering-gitlab-runner.png\" class=\"kg-image\" alt=\"Registering the GitLab runner\"><figcaption>Registering the GitLab runner</figcaption></figure><ul><li>Choose <code><strong><strong>https://gitlab.com/</strong></strong></code> when prompted for gitlab-ci coordinator URL</li><li>Enter your token from above, ours is <code><strong><strong>YourRegistrationToken</strong></strong></code></li><li>Choose whatever description you want</li><li>Choose whatever tag you want, but remember what you chose <code><strong><strong>appditto_mac</strong></strong></code> in our case, will be used to target this specific runner when we create our pipeline.</li><li>For runner type, choose <code><strong><strong>shell</strong></strong></code></li></ul><p>Then all we do is install and start the runner, and it should run as a Launchd service that will start itself upon system reboots, etc.</p><pre><code># gitlab-runner install\n# gitlab-runner start</code></pre><p>You can refresh the gitlab settings page and you should see your runner appear.</p><h2 id=\"creating-our-pipeline\">Creating our Pipeline</h2><p>We saw how easy it was to install the gitlab-runner software and configure out server. Now we need to get into the fun stuff — creating our pipeline!</p><p>A <a href=\"https://docs.gitlab.com/ee/ci/pipelines.html\" rel=\"noopener nofollow\"><strong><strong>pipeline</strong></strong></a><strong><strong> </strong></strong>is basically just a set of jobs that may execute in a specific order. For example test -&gt; build -&gt; deploy. The pipeline is triggered on every commit (by default).</p><p>We’re going to design a relatively simple pipeline that can test, build, and deploy our app.</p><p>We’re going to create a file called <code><strong><strong>.gitlab-ci.yml</strong></strong></code> in the root of our project (<code><strong><strong>awesome_appditto_app/.gitlab-ci.yml</strong></strong></code>)</p><p>First part will be the <code><strong><strong>stages</strong></strong></code>, this defines all of the stages in our pipeline.</p><!--kg-card-begin: html--><script src=\"https://gist.github.com/bbedward/bdcbd6cc207d9eb02670f68228829bb5.js\"></script><!--kg-card-end: html--><ul><li><code><strong><strong>test</strong></strong></code> — will be where we run our tests</li><li><code><strong><strong>update</strong></strong></code> — This is simply going to update our flutter dependencies, we want to run <code>flutter packages upgrade</code> every time because by default GitLab will “cache” the repository instead of cloning it every time (for speed), which means we aren’t guaranteed to have the latest versions of everything unless we do this.</li><li><code><strong><strong>build</strong></strong></code><strong><strong> </strong></strong>—<strong><strong> </strong></strong>This stage will build our android and iOS app.</li><li><code><strong><strong>deploy</strong></strong></code><strong><strong> </strong></strong>— This stage will deploy our android and iOS app.</li></ul><p>Every stage depends on the previous one. So if <code><strong><strong>test</strong></strong></code> fails then none of the other jobs will run, and the entire pipeline will be considered as failed.</p><p>—</p><p>First we can define a job in the <strong><strong>test</strong></strong> stage</p><!--kg-card-begin: html--><script src=\"https://gist.github.com/bbedward/1ed96e7e41c1b532d30ccf3cb5f65970.js\"></script><!--kg-card-end: html--><p>The job is named <strong><strong>tests</strong></strong>, it only runs when commits are pushed to the <strong><strong>master</strong></strong> branch, it is part of the <strong><strong>test</strong></strong> stage, it only will run on a runner with the <strong><strong>appditto_mac</strong></strong> tag, it executes one command <code><strong><strong>flutter test</strong></strong></code>and it is <strong><strong>interruptible</strong></strong> which means it can be cancelled automatically. If there are two pushes on the master branch, GitLab will cancel redundant pipeline runs automatically for us.</p><p>—</p><p>Then define a job in the <strong><strong>update</strong></strong> stage</p><!--kg-card-begin: html--><script src=\"https://gist.github.com/bbedward/ec7ea86196b4037d794d699ae6425fff.js\"></script><!--kg-card-end: html--><p>Very similar to the <strong><strong>test </strong></strong>job, except we’re running two commands instead of only 1: <code><strong><strong>flutter packages get</strong></strong></code> and <code><strong><strong>flutter packages upgrade</strong></strong></code>.</p><p>—</p><p>Then we can define our <strong><strong>build</strong></strong> stage. This one consists of two jobs and gets a bit more interesting.</p><!--kg-card-begin: html--><script src=\"https://gist.github.com/bbedward/14a65f0080d59fb4f5ebc7a2708f32c8.js\"></script><!--kg-card-end: html--><p>We have two jobs <strong><strong>android:build </strong></strong>and <strong><strong>ios:build</strong></strong>.</p><p>They are both just a series of shell commands like the previous jobs, although a bit more complicated. The <strong><strong>android:build</strong></strong> job is creating a <strong><strong>key.properties </strong></strong>and <strong><strong>local.properties</strong></strong> file on the fly, which is used by our android build to determine the SDK location as well as access the key store so it knows what to use for signing our app. We’ll get to defining our environment variables later, if you’re wondering what <code>$ANDROID_KEY_STORE_PASSWORD</code> and the others mean and how to define them.</p><p><strong><strong>ios:build</strong></strong> is creating some environment variables, <strong><strong>TEMP_KEYCHAIN_NAME</strong></strong> and <strong><strong>TEMP_KEYCHAIN_PASSWORD</strong></strong>. Remember how earlier we configured fastlane to create a temporary keychain for signing the app? This is just generating a random name and password for that key store on the fly.</p><p>Another new thing in this job is <code><strong><strong>artifacts</strong></strong></code>. We want to specify our build artifacts so GitLab can archive them for us. This includes our signed <code>.apk</code>, <code>.aab</code>, and <code>.ipa</code> files. After every successful <code><strong><strong>build</strong></strong></code><strong><strong> </strong></strong>stage GitLab will archive the build artifacts so we can come back and download them later, if desired.</p><p>—</p><p>We can then create some jobs for the deploy stage. We’ll create 4 total. One for production on Play Store (Android), one for App Store (iOS), one for Play Store internal track (Android), one for TestFlight (iOS)</p><!--kg-card-begin: html--><script src=\"https://gist.github.com/bbedward/b58be56cb6f422848c252b032a46e2a9.js\"></script><!--kg-card-end: html--><p>There’s 4 jobs that are part of the deploy stage, you can see that they simply execute some of the <strong><strong>fastlane</strong></strong> lanes that we created earlier with various options.</p><p>The main difference with these is <code><strong><strong>when: manual</strong></strong></code>. We don’t want these deploy jobs to be triggered automatically, because we don’t want to push builds to the AppStore/Play Store every time a new commit is pushed. So with this option, these jobs can be triggered manually after the build stage is complete.</p><p>Here’s the entire <code><strong><strong>gitlab-ci.yml</strong></strong></code><strong><strong> </strong></strong>that we put together, for reference.</p><!--kg-card-begin: html--><script src=\"https://gist.github.com/bbedward/a0fb271da243c408ae864bf3b1891610.js\"></script><!--kg-card-end: html--><p>You can do a lot more things with your pipeline. For example, with our open source app we also want to automate release tagging and upload APKs to GitHub, you can see that <a href=\"https://github.com/appditto/natrium_wallet_flutter/blob/master/.gitlab-ci.yml\" rel=\"noopener nofollow\"><strong><strong>here</strong></strong></a> for reference.</p><p>Check the file in and push it to your repository. You should the job trigger immediately.</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://ghost.appditto.com/content/images/2019/11/gitlab-complete-pipeline.png\" class=\"kg-image\" alt=\"Completed Pipeline — We’ll Address the Failure Next\"><figcaption>Completed Pipeline — We’ll Address the Failure Next</figcaption></figure><h2 id=\"setting-up-environment-variables\">Setting up environment variables</h2><p>Your android build probably failed if you’ve been following this guide. We had specified some environment variables in our .gitlab-ci.yml but didn’t define them anywhere.</p><p>We need to define the following:</p><ul><li><code><strong><strong>FLUTTER_PATH</strong></strong></code><strong><strong> — </strong></strong>This is the location you installed flutter on the server (example: <code>/Users/&lt;YOUR USER&gt;/flutter</code>)</li><li><code><strong><strong>ANDROID_SDK_PATH</strong></strong></code><strong><strong> — </strong></strong>This is the location the android SDK was installed on the server (example: <code>/Users/&lt;YOUR USER&gt;/Library/Android/sdk</code>)</li><li><code><strong><strong>ANDROID_KEY_STORE_PASSWORD</strong></strong></code><strong><strong> — </strong></strong>This is the <code>storePassword</code> value in our key.properties, AKA the password used to unlock your key store.</li><li><code><strong><strong>ANDROID_KEY_ALIAS</strong></strong></code><strong><strong> — </strong></strong>This is the name of the key used to sign your app, <code>keyAlias</code> in the key.properties file.</li><li><code><strong><strong>ANDROID_KEY_PASSWORD</strong></strong></code><strong><strong> — </strong></strong>This is the password for the key, <code>keyPassword</code> in the key.properties file.</li><li><code><strong><strong>ANDROID_KEYSTORE_PATH</strong></strong></code><strong><strong> — </strong></strong>This is the location of the <code>.jks</code> file. (example: <code>/Users/&lt;YOUR USER&gt;/android/keys/appditto.jks</code>)</li></ul><p>There’s two options for defining these variables that we’re going to cover.</p><ol><li>Placing them in <code><strong><strong>~/.zprofile</strong></strong></code> (Catalina and newer) or <code><strong><strong>~/.profile</strong></strong></code> (Mojave and older).</li><li>Setting them up in the GitLab interface.</li></ol><p>We already briefly covered #1, we’re going to choose #2 this time. There’s pros and cons to each approach but ultimately it’ll be up to you to decide.</p><p>Adding them in GitLab is very simple, just navigate to your project settings as seen below and add them:</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://ghost.appditto.com/content/images/2019/11/environment-variables.png\" class=\"kg-image\" alt=\"Setting Environment Variables for your GitLab Project\"><figcaption>Setting Environment Variables for your GitLab Project</figcaption></figure><p>And we can re-run our pipeline and can see that it passed!</p><figure class=\"kg-card kg-image-card kg-card-hascaption\"><img src=\"https://ghost.appditto.com/content/images/2019/11/gitlab-finished-pipeline.png\" class=\"kg-image\" alt=\"Finished GitLab Pipeline\"><figcaption>Finished GitLab Pipeline</figcaption></figure><p>We can see that our deploy jobs did not get triggered, which is what we wanted. When we want to deploy it to the app store we can just login to GitLab and manually run whichever deployment we want.</p><h2 id=\"let-s-recap\">Let’s Recap</h2><p>We’ve successfully automated our workflow using GitLab CI/CD and Fastlane.</p><ul><li>On every commit to <code>master</code>, all of our tests and both builds will run</li><li>On successful builds, GitLab will archive the binaries so they are available for us to download later if needed.</li><li>Also on successful builds, our binaries will be available for us to deploy at our leisure with the press of a button.</li><li>If our tests or builds are failing, GitLab will alert us of the failure based on our preferences (email is the default)</li></ul><p>Now our code is continuously tested, built, and the latest builds are ready to deploy!</p><h2 id=\"thanks-for-reading-\">Thanks for reading!</h2><figure class=\"kg-card kg-image-card\"><img src=\"https://ghost.appditto.com/content/images/2020/01/appditto-preview-1.png\" class=\"kg-image\" alt=\"Don't forget to follow Appditto on social media\"></figure><p>Appditto Website: <a href=\"http://appditto.com/\" rel=\"noopener nofollow\"><strong><strong>appditto.com</strong></strong></a></p><p>Appditto Twitter: <a href=\"http://twitter.com/appditto\" rel=\"noopener nofollow\"><strong><strong>@appditto</strong></strong></a></p><p>Appditto Github: <a href=\"http://github.com/appditto\" rel=\"noopener nofollow\"><strong><strong>@appditto</strong></strong></a></p><p>Appditto Instagram: <a href=\"http://instagram.com/appditto\" rel=\"noopener nofollow\"><strong><strong>@appditto</strong></strong></a></p>","comment_id":"5ddbb8dde4679ea23a15023b","feature_image":"https://ghost.appditto.com/content/images/2019/12/flutter-automation-2-2.png","featured":false,"visibility":"public","created_at":"2019-11-25T11:19:57.000+00:00","updated_at":"2020-02-02T16:15:22.000+00:00","published_at":"2019-11-14T11:00:00.000+00:00","custom_excerpt":"Flutter is a modern mobile app development framework that lets you develop beautiful, highly performant apps. We already have multiple Flutter applications in production. The biggest pain point of our development process has been the testing, building, and deploying process for all of our apps.","codeinjection_head":null,"codeinjection_foot":null,"custom_template":null,"canonical_url":null,"url":"https://ghost.appditto.com/automate-your-flutter-workflow/","excerpt":"Flutter is a modern mobile app development framework that lets you develop beautiful, highly performant apps. We already have multiple Flutter applications in production. The biggest pain point of our development process has been the testing, building, and deploying process for all of our apps.","reading_time":19,"og_image":null,"og_title":null,"og_description":null,"twitter_image":null,"twitter_title":null,"twitter_description":null,"meta_title":null,"meta_description":null}